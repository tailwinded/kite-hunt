<!doctype html>
<html lang="en">
	<head>
		<title>kite-hunt</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>

	<body>
		

		<script src="http://mrdoob.github.com/three.js/build/Three.js"></script>
		<script src="js/ShaderExtras.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="js/ImprovedNoise.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 2048;

			var MARGIN = 100;

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN;
			var FLOOR = -250;

			var camera, controls, scene, renderer, color, materials = [];
			var container, stats;

			var worldWidth = 32, worldDepth = 32,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var NEAR = 5, FAR = 50000;

			var sceneHUD, cameraOrtho, hudMaterial;

			var morph, morphs = [];

			var objects = [];
			var flows = [];

			var light;

			var postprocessing = { enabled  : true };
			var material_depth;

			var clock = new THREE.Clock();

			init();
			animate();


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// SCENE

				scene = new THREE.Scene();
				//scene.fog = new THREE.Fog( 0xBCD2EE, 1000, 5500 );
				scene.fog = new THREE.FogExp2( 0xBCD2EE, 0.0001 );
				//THREE.ColorUtils.adjustHSV( scene.fog.color, 0.02, 0.15, -0.65 );

				// SCENE CAMERA

				camera = new THREE.PerspectiveCamera( 30, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
				camera.position.set( 2000, 500, 1900 );
				scene.add( camera );


				// LIGHTS

				var ambient = new THREE.AmbientLight( 0x555555 );
				scene.add( ambient );

				light = new THREE.SpotLight( 0xF0F0F0 );
				light.position.set( -1000, 3000, 2500 );
				light.target.position.set( 0, 0, 0 );

				light.castShadow = true;

				light.shadowCameraNear = 700;
				light.shadowCameraFar = camera.far;
				light.shadowCameraFov = 50;

				//light.shadowCameraVisible = true;

				light.shadowBias = 0.0001;
				light.shadowDarkness = 0.7;

				light.shadowMapWidth = SHADOW_MAP_WIDTH;
				light.shadowMapHeight = SHADOW_MAP_HEIGHT;

				scene.add( light );

				createScene();
				initPostprocessing();

				// RENDERER

				renderer = new THREE.WebGLRenderer( { clearColor: 0x000000, clearAlpha: 1, antialias: false } );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.domElement.style.position = "relative";
				renderer.domElement.style.top = MARGIN + 'px';
				container.appendChild( renderer.domElement );

				renderer.setClearColor( scene.fog.color, 1 );
				renderer.autoClear = false;

				//

				renderer.shadowMapEnabled = true;
				renderer.shadowMapSoft = true;

				// FP CONTROLS

				// controls = new THREE.FirstPersonControls( camera, renderer.domElement );

				// controls.lookSpeed = 0.01;
				// controls.movementSpeed = 500;
				// controls.noFly = false;
				// controls.lookVertical = true;
				// controls.heightCoef  = 0.5
				// controls.constrainVertical = true;
				// controls.verticalMin = 1.5;
				// controls.verticalMax = 2.0;
				// //controls.activeLook = false;
				// //controls.freeze = true;

				// controls.lon = -110;

				// // TRACKBALL CONTROLS

				controls = new THREE.TrackballControls( camera, renderer.domElement );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];


				// STATS

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				//EXTRA CONTROLS

				window.addEventListener('keydown', function(ev) {
       				switch (ev.keyCode) {
        				case 'C'.charCodeAt(0): 
          				addCube(camera.position); break;
      				}
    			}, false);

    			//GUI

    			var effectController  = {

					focus: 		0.42,
					aperture:	0.0486,
					maxblur:	1.0,
					terrain: "#ffffff",
					light: "#ffffff"

				};

				var matChanger = function( ) {


					var hexColor = function(stdHex) {

						return '0x'+stdHex.slice(1, 7);

					} 

					var hextorgb = function(hex){
						var r = ( hex >> 16 & 255 ) / 255;
						var g = ( hex >> 8 & 255 ) / 255;
						var b = ( hex & 255 ) / 255;

						return [r, g, b];
					};

					postprocessing.bokeh_uniforms[ "focus" ].value = effectController.focus;
					postprocessing.bokeh_uniforms[ "aperture" ].value = effectController.aperture;
					postprocessing.bokeh_uniforms[ "maxblur" ] = effectController.maxblur;
					var terrainRGB = hextorgb(hexColor(effectController.terrain));
					ground.material.color.setRGB(terrainRGB[0], terrainRGB[1], terrainRGB[2]);
					var lightRGB = hextorgb(hexColor(effectController.light));
					light.color.setRGB(lightRGB[0], lightRGB[1], lightRGB[2]);

				};

				

				var gui = new dat.GUI();
				gui.domElement.parentNode.style.zIndex = 11;
				gui.add( effectController, "focus", -1.0, 3.0, 0.025 ).onChange( matChanger );
				gui.add( effectController, "aperture", 0.001, 0.2, 0.001 ).onChange( matChanger );
				gui.add( effectController, "maxblur", 0.0, 3.0, 0.025 ).onChange( matChanger );
				gui.addColor(effectController, 'terrain').onChange( matChanger );
				gui.addColor(effectController, 'light').onChange( matChanger );

			}

			function initPostprocessing () {

        		var height = window.innerHeight - 300;

        		postprocessing.scene = new THREE.Scene();

        		postprocessing.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2,  window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );
        		postprocessing.camera.position.z = 100;

        		postprocessing.scene.add(postprocessing.camera);

        		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
        		postprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( window.innerWidth, height, pars );
        		postprocessing.rtTextureColor = new THREE.WebGLRenderTarget( window.innerWidth, height*2, pars );

        		var bokeh_shader = THREE.ShaderExtras[ "bokeh" ];

        		postprocessing.bokeh_uniforms = THREE.UniformsUtils.clone( bokeh_shader.uniforms );
        		postprocessing.bokeh_uniforms[ "tColor" ].texture = postprocessing.rtTextureColor;
        		postprocessing.bokeh_uniforms[ "tDepth" ].texture = postprocessing.rtTextureDepth;
        		postprocessing.bokeh_uniforms[ "focus" ].value = 0.42;
        		postprocessing.bokeh_uniforms[ "aperture" ].value = 0.0486;
        		postprocessing.bokeh_uniforms[ "maxblur" ].value = 1;
       			postprocessing.bokeh_uniforms[ "aspect" ].value = window.innerWidth / height ;

        		postprocessing.materialBokeh = new THREE.ShaderMaterial( {

          			uniforms:  postprocessing.bokeh_uniforms,
          			vertexShader: bokeh_shader.vertexShader,
          			fragmentShader: bokeh_shader.fragmentShader

        		} );

        		postprocessing.quad = new THREE.Mesh( new THREE.PlaneGeometry( window.innerWidth, window.innerHeight ), postprocessing.materialBokeh );
        		postprocessing.quad.position.z = - 500;
        		postprocessing.quad.rotation.x = Math.PI / 2;
        		postprocessing.scene.add( postprocessing.quad );

    		}

			function addCube(pos){

					var rand = Math.random()*0.5;
					var randForm = Math.round((Math.random()));
					if (randForm === 0){
						var objGeo = new THREE.CylinderGeometry(0, 100, 150, 3, 1 );
					}
					if (randForm === 1){
						var objGeo = new THREE.SphereGeometry(rand*100,rand*100,rand*100);
					}
					
					
					randColor = '0x'+Math.floor(Math.random()*16777215).toString(16);
    				var objMat = new THREE.MeshPhongMaterial({color: randColor});
    				var obj = new THREE.Mesh(objGeo, objMat);

   					obj.geometry.dynamic = true;
   					// changes to the vertices
    				obj.geometry.__dirtyVertices = true;
    				// changes to the normals
    				obj.geometry.__dirtyNormals = true;

    				obj.position.set( pos.x, pos.y, pos.z );
    				obj.rotation.y = Math.PI/2;

    				obj.castShadow = true;
    				obj.receiveShadow  = false;

    				objects.push(obj);
    				scene.add(obj);

			}

			function createScene( ) {

				// GROUND

				geometry = new THREE.PlaneGeometry( 20000, 20000, worldWidth - 1, worldDepth - 1 );
				geometry.dynamic = true;

				var i, j, il, jl;

				for ( i = 0, il = geometry.vertices.length; i < il; i ++ ) {

					//console.log(geometry.vertices[ i ]);

					geometry.vertices[ i ].y = 200 * Math.sin( i/2 )*Math.sin(Math.random()*i);
				
					//geometry.vertices[ i ].position.x = -35 * Math.sin( i/2 )*Math.random()*1;

				}

				geometry.computeFaceNormals();
				geometry.computeVertexNormals();

				material = new THREE.MeshLambertMaterial( { color: 0xffffff } );

				ground = new THREE.Mesh( geometry, material );
				ground.rotation.y = - 90 * Math.PI / 180;
				

				// var geometry = new THREE.PlaneGeometry( 1000, 1000 );
				// var planeMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
				// THREE.ColorUtils.adjustHSV( planeMaterial.color, 0, 0, 0.9 );
				// planeMaterial.ambient = planeMaterial.color;

				// var ground = new THREE.Mesh( geometry, planeMaterial );

				 ground.position.set( 0,  0, FLOOR);
				// ground.rotation.x = -Math.PI/2;
				//ground.scale.set( 100, 100, 100 );

				ground.castShadow = false;
				ground.receiveShadow = true;

				scene.add( ground );

				// PARTICLES

				geometry = new THREE.Geometry();
				geometry.dynamic = true;


				for ( i = 0; i < 100000; i ++ ) {

					vector = new THREE.Vector3( Math.random() * 5000 - i/100, Math.random() * 5000 - i/100, Math.random() * 5000 - i/1000 );
					vector.velocity = new THREE.Vector3(0,-Math.random(), 0); 
					geometry.vertices.push(  vector  );

				}

				//parameters = [ [ [1.0, 1.0, 1.0], 5 ], [ [0.95, 1, 1], 4 ], [ [0.90, 1, 1], 3 ], [ [0.85, 1, 1], 2 ], [ [0.80, 1, 1], 1 ] ];
				parameters = [ [ 0xff0000, 50 ], [ 0xff3300, 40 ], [ 0xff6600, 30 ], [ 0xff9900, 2 ], [ 0xffaa00, 10 ] ];
				//parameters = [ [ 0xffffff, 5 ], [ 0xdddddd, 4 ], [ 0xaaaaaa, 3 ], [ 0x999999, 2 ], [ 0x777777, 1 ] ];

				for ( i = 0; i < parameters.length; i ++ ) {

					size  = parameters[i][1];
					color = parameters[i][0];

					//materials[i] = new THREE.ParticleBasicMaterial( { color: color, size: size } );

					materials[i] = new THREE.ParticleBasicMaterial( { size: size } );
					materials[i].color.setHSV( color[0], color[1], color[2] );

					particles = new THREE.ParticleSystem( geometry, materials[i] );

					particles.rotation.x = Math.random() * 6;
					particles.rotation.y = Math.random() * 6;
					particles.rotation.z = Math.random() * 6;
					//particles.position.set( 0,  0, FLOOR+500);

					

				}
				particles.receiveShadow = true;
				particles.castShadow = true;

				flows.push(particles);

				scene.add( particles );


				// CUBES

				var planeMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );

				var mesh = new THREE.Mesh( new THREE.CubeGeometry( 1500, 1500, 1500 ), planeMaterial );

				mesh.position.y = FLOOR + 750;
				mesh.position.z = 20;

				mesh.castShadow = true;
				mesh.receiveShadow = true;

				scene.add( mesh );

				//objects.push(mesh);

				// var mesh = new THREE.Mesh( new THREE.CubeGeometry( 1500, 170, 20 ), planeMaterial );

				// mesh.position.y = FLOOR - 50;
				// mesh.position.z = 20;

				// mesh.castShadow = true;
				// mesh.receiveShadow = true;

				// scene.add( mesh );

				//objects.push(mesh);


			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var delta = clock.getDelta();
				var time = clock.getElapsedTime() * 10;

				var seconds		= Date.now()/1000
				var piPerSeconds	= seconds * Math.PI;
			
				// light.position.x	= 1000+Math.sin(piPerSeconds*0.05)*2200;
				// light.position.y	= 1000 + Math.sin(piPerSeconds*0.5)*4;
				// light.position.z	= Math.cos(piPerSeconds*0.05)*1200;

				for ( var i = 0; i < objects.length; i ++ ){
					// objects[i].position.x	+= Math.sin(piPerSeconds*Math.random()*0.5)*3;
					objects[i].position.y += Math.sin(piPerSeconds*Math.random()*Math.sin(piPerSeconds))*4;
					// objects[i].position.z	+= Math.cos(piPerSeconds*Math.random()*0.5)*3;
					if ( i % 2 == 0){
						objects[i].position.x += Math.cos(piPerSeconds*2)*10;
    					//objects[i].scale.y = Math.random()*10;
    					//objects[i].scale.z = Math.random()*10;
					}

					else{
						objects[i].position.z += Math.cos(piPerSeconds*1)*10;
    					//objects[i].scale.y = Math.random()*10;
    					//objects[i].scale.z = Math.random()*10;
					}
				}
				
				for ( var i = 0, l = ground.geometry.vertices.length; i < l; i ++ ) {

					var pos = ground.geometry.vertices[ i ].y;
					ground.geometry.vertices[ i ].y = pos+100*Math.sin(i-time);

					//particles.geometry.vertices[ i ].x += Math.sin(i-time/10);


				}



				ground.geometry.__dirtyVertices = true;

				particles.rotation.z += 0.001;

				for ( var i = 0, l = particles.geometry.vertices.length; i < l; i ++ ) {

					var particle = particles.geometry.vertices[ i ];
					if(particle.y < -2000) {
      					particle.y = 2000;
      					particle.velocity.y = 0;
    				}
					
					particle.velocity.y -= Math.random() * 100;
					particle.addSelf(particle.velocity);


				}

				particles.geometry.__dirtyVertices = true;

				controls.update( delta );

				if (this.postprocessing.enabled ) {

          			renderer.clear();

          			// Render scene into texture

          			scene.overrideMaterial = null;
          			renderer.render( scene, camera, postprocessing.rtTextureColor, true );

          			// Render depth into texture

          			scene.overrideMaterial = material_depth;
          			renderer.render( scene, camera, postprocessing.rtTextureDepth, true );

          			// Render bokeh composite

          			renderer.render( postprocessing.scene, postprocessing.camera );
          			//postprocessing.bokeh_uniforms[ "aspect" ].value = window.innerWidth / window.innerHeight / Math.sin(Math.random()*10);

        		} else {

          			renderer.clear();
          			renderer.render(scene, camera );

        		}


				// Render debug HUD with shadow map

				// hudMaterial.uniforms.tDiffuse.texture = light.shadowMap;
				// renderer.render( sceneHUD, cameraOrtho );

			}

		</script>

	</body>
</html>
